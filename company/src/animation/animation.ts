import {Point} from "../geometry/point";
import {WebMercator} from "../projection/web-mercator";
import {Projection} from "../projection/projection";
import {Polyline} from "../geometry/polyline";
import {LineSymbol, SimpleLineSymbol} from "../symbol/symbol";
import {Bound} from "../util/bound";
/**
 * 动画效果基类
 * @remarks
 * 动画两种实现方式：
 * 1.针对单个图形要素，实现动画，使用时，逻辑较清晰；
 * 2.针对整个图层，类似Symbol，使用时，可能存在效率问题；
 * 目前暂实现1，针对2，目前保留部分已注释的代码，便于日后参考。
 */
export class Animation {
    /**
     * 动画效果初始化
     * @remarks
     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文
     * @param {Projection} projection - 坐标投影转换
     */
    init(ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator()) {

    }
    /**
     * 动画效果
     * @remarks
     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数
     * @param {number} elapsed - 已逝去的时间，毫秒
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文
     */
    animate(elapsed, ctx: CanvasRenderingContext2D) {

    }

}

/**
 * 点默认动画效果类
 * @remarks
 * 类似flashing效果，从中心点向外光环扩散效果
 */
export class PointAnimation extends Animation {
    protected _point: Point;
    protected _screenX: number;
    protected _screenY: number;
    /**
     * 边宽
     */
    lineWidth: number = 2;
    /**
     * 颜色
     */
    color: string = "#ff0000";
    /**
     * 扩散速度
     */
    velocity: number = 10;   //  px/s
    /**
     * 扩散的最大半径
     */
    limit: number = 30;
    /**
     * 扩散的光圈数
     */
    ring: number = 3;
    //radius: number = this.limit / this.ring;
    /**
     * 创建动画效果
     * @param {Point} geometry - 点
     */
    constructor(geometry: Point) {
        super();
        this._point = geometry;
    }
    /**
     * 动画效果初始化
     * @remarks
     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文
     * @param {Projection} projection - 坐标投影转换
     */
    init(ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator()) {
        this._point.project(projection);
        const matrix = (ctx as any).getTransform();
        this._screenX = (matrix.a * this._point.x + matrix.e);
        this._screenY = (matrix.d * this._point.y + matrix.f);
        /*ctx.save();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        //keep size
        //地理坐标 转回 屏幕坐标
        ctx.setTransform(1,0,0,1,0,0);
        ctx.beginPath(); //Start path
        ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);
        ctx.stroke();
        ctx.restore();*/
    }
    /**
     * 动画效果
     * @remarks
     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数
     * @param {number} elapsed - 已逝去的时间，毫秒
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文
     */
    animate(elapsed, ctx: CanvasRenderingContext2D) {
        ctx.save();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        //keep size
        //地理坐标 转回 屏幕坐标
        ctx.setTransform(1,0,0,1,0,0);
        /*ctx.arc(this._screenX, this._screenY, this.limit / this.ring, 0, Math.PI * 2, true);
        ctx.fill();*/
        for (let i = 0; i < this.ring; i++) {
            ctx.beginPath(); //Start path
            ctx.arc(this._screenX, this._screenY, (elapsed/1000 * this.velocity + i * this.limit / this.ring) % this.limit, 0, Math.PI * 2, true);
            //ctx.arc(this._screenX, this._screenY, this.limit / this.ring + ((elapsed/1000 + (this.limit - this.limit / this.ring) / this.velocity * (i/(this.ring - 1))) * this.velocity) % this.limit, 0, Math.PI * 2, true);
            ctx.stroke();
        }
        ctx.restore();
    }

}

/**
 * 线默认动画效果类
 * @remarks
 * 类似航线效果
 */
export class LineAnimation extends Animation {
    protected _polyline: Polyline;
    protected _screen: number[][];

    private _start: number[];
    private _end: number[];

    private _control: number[];
    private _percent = 0;
    /**
     * 线宽
     */
    lineWidth: number = 2;
    /**
     * 起始色
     */
    startColor: string = "#ff0000";
    /**
     * 终止色
     */
    endColor: string = "#ffff00";
    /**
     * 二次贝塞尔曲线控制点与线段夹角
     */
    angle: number = Math.PI / 4;
    /**
     * 创建动画效果
     * @param {Polyline} geometry - 线
     */
    constructor(geometry: Polyline) {
        super();
        this._polyline = geometry;
    }
    /**
     * 动画效果初始化
     * @remarks
     * 一般情况下，把一次性逻辑放于此处，以及处理动画的初始状态
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文
     * @param {Projection} projection - 坐标投影转换
     */
    init(ctx: CanvasRenderingContext2D, projection: Projection = new WebMercator()) {
        this._polyline.project(projection);
        const matrix = (ctx as any).getTransform();
        this._screen = this._polyline.coordinates.map( (point: any,index) => {
            const screenX = (matrix.a * point[0] + matrix.e), screenY = (matrix.d * point[1] + matrix.f);
            return [screenX, screenY];
        });
        //TODO: polyline, not line; but now just line
        this._start = this._screen[0];
        this._end = this._screen[1];

        const k = (this._end[1] - this._start[1]) / (this._end[0] - this._start[0]);
        const d = Math.sqrt( (this._end[1] - this._start[1]) * (this._end[1] - this._start[1])  + (this._end[0] - this._start[0]) * (this._end[0] - this._start[0]));
        const s = d/2 / Math.cos(this.angle);
        //const a = (Math.atan(k) < 0 ? (Math.PI +  Math.atan(k)) : Math.atan(k)) - this.angle;
        //this._control = this._start[0] >= this._end[0] ? [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)] : [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];
        const a = Math.atan(k) - this.angle;
        if (Math.atan(k) < 0) {
            if (this._end[0] > this._start[0]) {
                this._control = [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)];
            } else {
                this._control = [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];
            }
        } else {
            if (this._end[0] > this._start[0]) {
                this._control = [this._start[0] + s * Math.cos(a), this._start[1] + s * Math.sin(a)];
            } else {
                this._control = [this._end[0] + s * Math.cos(a), this._end[1] + s * Math.sin(a)];
            }
        }
        this._percent = 0;
    }

    /**
     * 动画效果
     * @remarks
     * 通过Animator中requestAnimationFrame循环调用，因此注意优化代码，保持帧数
     * @param {number} elapsed - 已逝去的时间，毫秒
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文
     */
    animate(elapsed, ctx: CanvasRenderingContext2D) {
        ctx.save();
        ctx.lineWidth = this.lineWidth;
        //keep size
        //地理坐标 转回 屏幕坐标
        ctx.setTransform(1,0,0,1,0,0);

        const lineGradient = ctx.createLinearGradient(this._start[0], this._start[1], this._end[0], this._end[1]);
        lineGradient.addColorStop(0, this.startColor);
        // lineGradient.addColorStop(0.3, '#fff');
        lineGradient.addColorStop(1, this.endColor);
        ctx.strokeStyle = lineGradient;    //设置线条样式

        this._drawCurvePath(ctx, this._start, this._control, this._end, this._percent);

        this._percent += 0.8; //进程增加,这个控制动画速度

        if (this._percent >= 100) { //没有画完接着调用,画完的话重置进度
            this._percent = 100;
  

        }
    }

    _drawCurvePath(ctx, start, point, end, percent) {
        ctx.beginPath();
        ctx.moveTo(start[0], start[1]);
        for (let t = 0; t <= percent / 100; t += 0.005) {
            let x = this._quadraticBezier(start[0], point[0], end[0], t);
            let y = this._quadraticBezier(start[1], point[1], end[1], t);
            ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    _quadraticBezier(p0, p1, p2, t) {
        let k = 1 - t;
        return k * k * p0 + 2 * (1 - t) * t * p1 + t * t * p2; // 二次贝赛尔曲线方程
    }
}